# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MorfoCuencasDialog
                                 A QGIS plugin
 Este plugin permite hacer una caracterización de una cuenca morfométrica...
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-06-17
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Sebastian Sierra, David Duarte
        email                : ssierrab@correo.udistrital.edu.co, djduartea@correo.udistrital.edu.co
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math
import shutil
import processing
from osgeo import ogr #Para leer el gpkg
from qgis.gui import QgsMapToolEmitPoint
from qgis.core import QgsRasterLayer
from qgis.core import QgsVectorLayer
from qgis.core import QgsRasterBandStats
from qgis.core import QgsField
from qgis.PyQt.QtCore import QVariant
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import QgsProject
from qgis.utils import iface
from qgis.core import NULL 
from PyQt5.QtWidgets import QMessageBox
from qgis.core import QgsVectorFileWriter
import matplotlib.pyplot as plt
import pandas as pd
from qgis.gui import QgsMapTool
from PyQt5.QtCore import Qt

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MorfoCuencas_dialog_base.ui'))

#Funcion implementada para calculo de orden
def comprobar(capa_drenajes):
    capa_drenajes.selectByExpression( "\"orden\" is Null" )
    selFea=capa_drenajes.selectedFeatures()
    return len(selFea)

#Funciones implementadas para calculo de cauce principal
def selector(listaid,listaorden,orden_sup,tramo_iniFea,idCont,provider,capa_drenajes):
    """Marcar P o N para segmento y 
    revisa si existe un segmento de orden igual"""
    index = listaorden.index(max(listaorden))
    id_analisis=listaid[index]
    if(orden_sup==max(listaorden)):
        print("si hay")
        #capa en ese id como p
        attr_value={idCont:"P"}
        #Aca se marca el orden superior
        provider.changeAttributeValues({id_analisis:attr_value})
        capa_drenajes.removeSelection()
        #Aca se marcan los otros...
        listaid.remove(id_analisis)
        capa_drenajes.select(id_analisis)
        sel_id=capa_drenajes.selectedFeatures()
        attr_value={idCont:"N"}
        provider.changeAttributeValues({listaid[0]:attr_value})
        print("paso por el if de selector")
    else:
        print("no hay")
        if(orden_sup!=1): 
            capa_drenajes.removeSelection()
            capa_drenajes.select(listaid[0])
            caminoA=capa_drenajes.selectedFeatures()[0]
            capa_drenajes.removeSelection()
            capa_drenajes.select(listaid[1])
            caminoB=capa_drenajes.selectedFeatures()[0]
            lista_longitudes=[]
            if(orden_sup==2):
                lista_longitudes.append(caminoA.geometry().length())
                lista_longitudes.append(caminoB.geometry().length())
            else:
                lista_longitudes.append(funcion_longitud(caminoA,tramo_iniFea,orden_sup,capa_drenajes))
                lista_longitudes.append(funcion_longitud(caminoB,tramo_iniFea,orden_sup,capa_drenajes))
            print(str(lista_longitudes)+"--> lista de longitudes")
            index=lista_longitudes.index(max(lista_longitudes))
            id_analisis=listaid[index]
            attr_value={idCont:"P"}
            #Aca se marca el orden superior
            provider.changeAttributeValues({id_analisis:attr_value})
            capa_drenajes.removeSelection()
            listaid.remove(id_analisis)
            capa_drenajes.select(id_analisis)
            attr_value={idCont:"N"}
            provider.changeAttributeValues({listaid[0]:attr_value})
            print("paso por el else de selector")
    return id_analisis

def selectora(listaid,listaorden,orden_sup,tramo_iniFea,idCont,provider,capa_drenajes):
    """Marcar P o N para segmento y 
    revisa si existe un segmento de orden igual"""
    idControl=idCont
    layer_provider=provider
    layer_drenajes=capa_drenajes
    index = listaorden.index(max(listaorden))
    id_analisis=listaid[index]
    if(orden_sup==max(listaorden)):
        print("si hay")
        #capa en ese id como p
        attr_value={idControl:"P"}
        #Aca se marca el orden superior
        layer_provider.changeAttributeValues({id_analisis:attr_value})
        layer_drenajes.removeSelection()
        #Aca se marcan los otros...
        listaid.remove(id_analisis)
        layer_drenajes.select(id_analisis)
        sel_id=layer_drenajes.selectedFeatures()
        attr_value={idControl:"N"}
        layer_provider.changeAttributeValues({listaid[0]:attr_value})
        print("paso por el if de selector")
    return id_analisis
    


def tocanA(capa_drenajes,iniFea):
    """Genera listas id y orden de las corrientes 
    que tocan aguas arriba un tramo principal"""
    capa_drenajes.removeSelection()
    capa_drenajes.selectByExpression( "\"Principal\" is Null" )
    selfea_d=capa_drenajes.selectedFeatures()
    to_id,to_orden=[],[]
    for d in selfea_d:
        if(d.geometry().touches(iniFea.geometry())):
            print(str(d.id())+' id')
            print(str(d['orden'])+' orden')
            to_id.append(d.id())
            to_orden.append(d['orden'])
    listas_tocana=[]
    listas_tocana.append(to_orden)
    listas_tocana.append(to_id)
    return listas_tocana

def tocanB(alterno_geom,antecesor_fea,capa_drenajes):  #B --> bifurcación (alterno es tipo geometria)
    """Genera listas id y orden de las corrientes 
    que tocan aguas arriba un tramo alterno"""
    layer_drenajes=capa_drenajes
    #Debe estar en memoria el primero del camino a evaluar
    layer_drenajes.removeSelection()
    #layer_drenajes.selectByExpression( "\"control\" is Null" )
    layer_drenajes.selectAll()
    selfea_d=layer_drenajes.selectedFeatures()
    to_idB,to_ordenB=[],[]
    for d in selfea_d: 
        if(d.geometry().touches(alterno_geom) and not (d.geometry().touches(antecesor_fea.geometry()))):  
            print(str(d.id())+' id')
            print(str(d['orden'])+' orden')
            to_idB.append(d.id())
            to_ordenB.append(d['orden'])
    indexAnt = to_idB.index(antecesor_fea.id())
    del to_idB[indexAnt]
    del to_ordenB[indexAnt]
    print(str(to_idB)+" idB")
    print(str(to_ordenB) + "ordenB")
    print("Paso por tocan B*************")
    listas_arg=[]
    listas_arg.append(to_ordenB)
    listas_arg.append(to_idB)
    return  listas_arg

def selector_alterno(alterno_fea,listaorden,listaid,orden_sup,capa_drenajes): #falta orden_sup
    """Obtiene la longitud de un elemento y extrae el id 
    de la siguiente corriente aguas arriba si tiene el mismo orden"""
    layer_drenajes=capa_drenajes
    index = listaorden.index(max(listaorden))
    id_analisis=listaid[index]
    criterio=1
    longitud_paso=alterno_fea.geometry().length()
    if(orden_sup==max(listaorden)):
        print("si hay")
        #Aca se marca el orden superior
        #Aca se marcan los otros...
        layer_drenajes.select(id_analisis)
        sel_id=layer_drenajes.selectedFeatures()
        layer_drenajes.removeSelection()
    else:
        criterio=0
        print("no hay")
    lista_sel=[]
    lista_sel.append(criterio)
    lista_sel.append(longitud_paso)
    lista_sel.append(id_analisis)
    return lista_sel
    print("Paso por selector alterno*************")

def funcion_longitud(featureaevaluar, antecesorfea, ordenviene,capa_drenajes):
    """Extrae la longitud total de una secuencia de tramos del mismo orden"""
    layer_drenajes=capa_drenajes
    longitud=0
    criterio=1
    interesfea=featureaevaluar
    previofea=antecesorfea
    while criterio==1:
        layer_drenajes.removeSelection()
        listas=tocanB(interesfea.geometry(),previofea,layer_drenajes) #actualizan valores de to_idB y to_ordenB
        listas_SA=selector_alterno(interesfea, listas[0], listas[1], (ordenviene-1),layer_drenajes)
        criterio=listas_SA[0]
        longitud=longitud+listas_SA[1]
        if(criterio==1):
            previofea=interesfea
            print(str(type(listas_SA[2]))+" " + str(listas_SA[2]))
            layer_drenajes.select(int(listas_SA[2]))
            interesfea=layer_drenajes.selectedFeatures()[0]
    print("termine un ciclo funcion longitud**********")
    return longitud
###****************************************************####
###*************FIN DE FUNCIONES***********************####
###*************CAUCE PRINCIPAL************************####

#Funciones implementadas para calculo de perfil del cauce principal
def get_name(f):
    return f['id_bueno']

def get_nameF(f):
    return f['id_final']

class SendPointToolCoordinates(QgsMapTool):
    """ Enable to return coordinates from clic in a layer.
    """
    def __init__(self, canvas=None, layer=QgsRasterLayer,contador=None):
        """ Constructor."""
        if (canvas is None or layer is None or contador is None):
            canvasA =iface.mapCanvas()
            QgsMapTool.__init__(self, canvasA)
            self.layer=layer
            self.canvas = canvasA
            self.setCursor(Qt.CrossCursor)
            self.contador=contador
            self.coordenadaX=None
            self.coordenadaY=None  
            i=contador  
            
    def asignAttributes(self,canvas,layer,contador):
            self.canvas = canvas
            self.layer = layer
            self.setCursor(Qt.CrossCursor)
            self.contador=contador
            self.coordenadaX=None
            self.coordenadaY=None  
            i=contador  
    def canvasReleaseEvent(self, event):
        point = self.toLayerCoordinates(self.layer, event.pos())
        #introducir if. es 0, con mensaje "escoja punto"
        #manejo de interfaz 
        if (self.coordenadaX is not None):
            iface.messageBar().pushMessage('Las coordenadas del PC son : '+str(self.coordenadaX)+','+str(self.coordenadaY))
        self.contador=self.contador+1
        self.coordenadaX=point.x()
        self.coordenadaY=point.y()          
        #self.canvas.unsetMapTool(self)
    
    def darCoordenadas(self):
        return [self.coordenadaX,self.coordenadaY]
        self.canvas.unsetMapTool(self)

    def sueltelo(self):
        return [self.coordenadaX,self.coordenadaY]

class MorfoCuencasDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(MorfoCuencasDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
        self.loadLayers()
        self.Boton.clicked.connect(self.Pbtn_clicked) #Conectando boton Pbtn_clicked (PushButton) cuando es clikeado
        self.Boton2.clicked.connect(self.Pbtn2_clicked) #Conectando boton Prueba (PushButton) cuando es clikeado
        self.btnExplorar.clicked.connect(self.btnExplorar_clicked) #Conectando boton Explorar
        self.btnActualizar.clicked.connect(self.btnActualizar_clicked) #Conectando boton Actualizar
        self.send_point_tool_coordinates=SendPointToolCoordinates()
        self.iniciar=0
        i=0
        self.CoordenadasPC=[]
    
    def send_point_tool_coordinatesSetter(self,canvas,entrada,contador):
        self.send_point_tool_coordinates.asignAttributes(canvas,entrada,contador)
    
    
    def loadLayers(self): #Cargar capas en combo box
        for layer in QgsProject.instance().mapLayers().values():
            self.cbbCargarCapas.addItem(layer.name(),layer)

    def btnExplorar_clicked(self):
        dir_ = QtWidgets.QFileDialog.getExistingDirectory(None, 'Select project folder:', 'C:\\', QtWidgets.QFileDialog.ShowDirsOnly)
        #self.lneSalida.value = dir_
        self.lneSalida.text = dir_+"/"
        self.lneSalida.setText(dir_)

    def btnActualizar_clicked(self):
        self.loadLayers()
    

    def Pbtn_clicked(self): #evento en Boton PushButton
        entrada=self.cbbCargarCapas.currentData() #Tome la capa actual del combo...
        self.iniciar = self.iniciar + 1
        directorioTrabajo=self.lneSalida.text #Tome el valor del directorio...
        if os.path.isdir(str(directorioTrabajo)):
            umbral=int(self.lneUmbral.text()) #Tome el valor del umbral...
            self.CoordenadasPC=self.Proceso(entrada,directorioTrabajo, umbral)  #Invoque la función Proceso
            canvas =iface.mapCanvas()
            i=10
            self.send_point_tool_coordinatesSetter(
                        canvas,
                        entrada,
                        i
                    )
            
            canvas.setMapTool(self.send_point_tool_coordinates)  
        else:
            QMessageBox.critical(self, "Error", 
              'La Ruta de Salida suministrada no es válida', QMessageBox.Ok)

    def Pbtn2_clicked(self): #evento en Boton PushButton
        if (self.iniciar > 0):
            entrada=self.cbbCargarCapas.currentData() #Tome la capa actual del combo...
            directorioTrabajo=self.lneSalida.text #Tome el valor del directorio...
            umbral=int(self.lneUmbral.text()) #Tome el valor del umbral...
            distancia=int(self.lneDistancia.text()) #Tome el valor del distancia...
            self.CoordenadasPC=self.send_point_tool_coordinates.darCoordenadas()
            self.lblCoordenadas.text='Las coordenadas del punto de concentración son: \n'+str(self.CoordenadasPC)
            self.lblCoordenadas.setText('Las coordenadas del punto de concentración son: \n'+str(self.CoordenadasPC))
            canvas =iface.mapCanvas()
            canvas.unsetMapTool(self.send_point_tool_coordinates)
            self.Proceso2(entrada,directorioTrabajo, umbral, distancia,self.CoordenadasPC)  #Invoque la función Proceso
        else:
            QMessageBox.information(self, "Información",
                                        'Primero debe dar clic al botón iniciar')
                

 
        
    def Proceso(self, capa, directorio, param_umbral):  #modulo proceso desencadenado en boton PushButton
        #processing.algorithmHelp("grass7:r.fill.dir")
        #directorio='D:/UD_SIG/PGRADO/Salida/'
        
        os.mkdir(directorio + 'Temp')
        os.mkdir(directorio + 'Img')
        umbral = param_umbral
        entrada=capa
        parameters = {
            'input':entrada,
            'output':directorio+'Img/'+'sinDepresiones.tif',
            'direction':directorio+'Img/'+'dir_pendiente.tif',
            'areas':directorio+'Img/'+'areas_dem_conflicto.tif',
            'format':'0'
        }
        ret = processing.run('grass7:r.fill.dir', parameters)

        input=directorio+'Img/'+'sinDepresiones.tif'
        rlayer = QgsRasterLayer(input, "sinDepresiones")
        #processing.algorithmHelp("grass7:r.watershed")
        parameters = {
        'elevation':input,
        'threshold':rlayer.rasterUnitsPerPixelX(),
        '-s':'1',
        'accumulation':directorio+'Img/'+'acumulacion.tif',
        'drainage':directorio+'Img/'+'direccion_flujo.tif' 
        }

        #####----#####
        #Agregar capa acumulacion y desplegarla
        #Mensaje para seleccionar punto de concentracion

        ret = processing.run("grass7:r.watershed", parameters)
        
        rlayer = QgsRasterLayer(directorio+'Img/'+'acumulacion.tif', "Raster de Acumulacion")
        QgsProject.instance().addMapLayer(rlayer, True)
        QMessageBox.information(self, "Punto de Concentración",
                                        'Seleccione el punto de concentración de la cuenca a delimitar y luego de clic al botón Finalizar')
        

    def Proceso2(self, capa, directorio, param_umbral, param_distancia,coordenadas):  #modulo proceso desencadenado en boton PushButton
        #processing.algorithmHelp("grass7:r.fill.dir")
        #directorio='D:/UD_SIG/PGRADO/Salida/'
        umbral = param_umbral
        distancia = param_distancia
        entrada=capa
        rlayer = QgsRasterLayer(directorio+'Img/', "sinDepresiones")

        
        input=directorio+'Img/'+'direccion_flujo.tif'
        coordenadas_concentracion = str(coordenadas[0])+','+str(coordenadas[1])
        print('holiiiii'+coordenadas_concentracion)
        parameters = {
        'input':input,
        'coordinates':coordenadas_concentracion, #'733096.0702514648,661317.473815918', #Parametrizar
        'output':directorio+'Temp/'+'divisoria_cuencas.tif'
        }
        ret = processing.run("grass7:r.water.outlet", parameters)

        input=directorio+'Temp/'+'divisoria_cuencas.tif'
        #processing.algorithmHelp("grass7:r.to.vect")
        parameters = {
        'input':input,
        'type':'2',
        'GRASS_OUTPUT_TYPE_PARAMETER':'3',
        'output':directorio+'divisoria_cuencas_poly.shp',
        '-s':1
        }
        ret = processing.run("grass7:r.to.vect", parameters)

        

        input=directorio+'Img/'+'sinDepresiones.tif'
        #processing.algorithmHelp("grass7:r.stream.extract")
        parameters = {
        'elevation':input,
        'accumulation':directorio+'Img/'+'acumulacion.tif',
        'threshold':umbral,
        'stream_vector':directorio+'Temp/'+'redDrenaje.gpkg',
        'GRASS_OUTPUT_TYPE_PARAMETER':2
        }
        ret = processing.run("grass7:r.stream.extract", parameters)                            
        
        ####Aqui empieza proceso de calculo de orden
        cuenca_poly = directorio + 'divisoria_cuencas_poly.shp'
        source = ogr.Open(directorio+'Temp/'+'redDrenaje.gpkg',update=False) #OJO quitar el /
        
        ####Aqui empieza proceso de calculo de orden
        drv = ogr.GetDriverByName( 'ESRI Shapefile' )
        for i in source:
            LayerName = i.GetName()
            inlyr = source.GetLayer( LayerName )
            outds = drv.CreateDataSource( directorio+'Temp/' + LayerName + '.shp')
            outlyr = outds.CopyLayer(inlyr,LayerName)

        del inlyr
        del outlyr
        del outds
        #ENTRADA para orden
        orden = directorio+'Temp/' + LayerName + '.shp'
        #Haciendo clip y generando capa de drenajes: orden
        drenajes = directorio + 'orden.shp'
        parameters = {
        'INPUT' : orden,
        'OUTPUT' : drenajes, 
        'OVERLAY' : cuenca_poly
        }
        ret = processing.run('native:clip', parameters)
        #Genera nodos de union de redes de drenaje
        intersecciones = directorio+'Temp/' + 'intersecciones.shp'
        processing.run('qgis:lineintersections', {'INPUT':drenajes,'INTERSECT':drenajes,'OUTPUT':intersecciones})
        #Disolver los puntos de las nodos (interseeciones)    
        disuelto = directorio+'Temp/' + 'disuelto.shp'
        parameters = {
        'COMPUTE_AREA' : False,
        'COMPUTE_STATISTICS' : False,
        'COUNT_FEATURES' : False,
        'EXPLODE_COLLECTIONS' : True,
        'FIELD' : '',
        'GEOMETRY' : 'geometry',
        'INPUT' : intersecciones,
        'OUTPUT' : disuelto,
        'OPTIONS' : '',
        'KEEP_ATTRIBUTES' : False,
        'STATISTICS_ATTRIBUTE' : ''
        }
        ret = processing.run('gdal:dissolve', parameters)
        #Calculando orden 1
        layer_drenajes = QgsVectorLayer(drenajes, "drenajes") 
        layer_drenajes.selectByExpression( "\"stream_typ\" = 'start'" )
        selFea=layer_drenajes.selectedFeatures()
        layer_provider=layer_drenajes.dataProvider()
        layer_provider.addAttributes([QgsField("orden",QVariant.Int)])
        layer_drenajes.updateFields()
        idOrden = layer_drenajes.fields().indexFromName('orden')
        layer_drenajes.startEditing()
        for i in selFea:
            attr_value={idOrden:1}
            layer_provider.changeAttributeValues({i.id():attr_value})

        layer_drenajes.commitChanges()
        #Calculando otro orden...
        layer_drenajes.selectAll()
        selfea_d=layer_drenajes.selectedFeatures()
        layer_inter = QgsVectorLayer(disuelto, "disuelto") 
        layer_inter.selectAll()
        selfea_i=layer_inter.selectedFeatures()

        longAntes=-1
        longAhora=0
        criterio=0
        
        while criterio!=3:
            layer_drenajes = QgsVectorLayer(drenajes, "drenajes") 
            layer_drenajes.selectAll()
            selfea_d=layer_drenajes.selectedFeatures()
            layer_inter = QgsVectorLayer(disuelto, "disuelto") 
            layer_inter.selectAll()
            selfea_i=layer_inter.selectedFeatures()
            layer_provider=layer_drenajes.dataProvider()
            idOrden = layer_drenajes.fields().indexFromName('orden')
            layer_drenajes.startEditing()
            triada=0
            for i in selfea_i:
                triada=triada+1
                print("grupo"+str(triada))
                to_select = []
                to_id = 0
                for d in selfea_d:
                    if i.geometry().intersects(d.geometry()):
                        to_select.append(d['orden'])
                        if(d['orden'] == NULL):
                            print("Hay un Nulo!")
                            print("Su id es:" + str(d.id()))
                            to_id=d.id()
                        print(d['orden'])
                n=to_select.count(NULL) 
                print(str(n)+"Nulos")
                if(n==1):
                    print("hay solo 1 nulo en "+str(triada))
                    to_select.sort(reverse=True)
                    print("mi orden: "+str(to_select[0]))
                    print("mi id de nulo: "+str(to_id))
                    to_select.remove(NULL)
                    if(len(to_select)!=len(set(to_select)) and len(to_select) == 2):
                        o=to_select[0]+1
                        print("Calcular con orden de los segmentos + 1: "+str(o))
                        attr_value={idOrden:o}
                        layer_provider.changeAttributeValues({to_id:attr_value})
                    else:
                        o=to_select[0]
                        print("Calcular con orden mayor: "+str(o))
                        attr_value={idOrden:o}
                        layer_provider.changeAttributeValues({to_id:attr_value})
                else:
                    print("debe pasar en "+str(triada))
                print(str(to_select)+"Aqui")
            layer_drenajes.commitChanges()
            longAntes=longAhora
            longAhora=comprobar(layer_drenajes)
            if(longAhora==longAntes):
                criterio=criterio+1
        
        ##poligono cuenca divisoria a lineas##
        cuenca_l = directorio+'Temp/' + 'cuenca_linea.shp'
        processing.run("qgis:polygonstolines", {'INPUT':cuenca_poly,'OUTPUT':cuenca_l})
        
        layer_drenajes = QgsVectorLayer(drenajes, "drenajes") 
        layer_drenajes.selectAll()
        selfea_d=layer_drenajes.selectedFeatures()
        layer_cuenca = QgsVectorLayer(cuenca_l, "cuenca") 
        layer_cuenca.selectAll()
        selfea_c=layer_cuenca.selectedFeatures() ##cambio peligroso
        
        layer_provider=layer_drenajes.dataProvider()
        layer_drenajes.startEditing()
        layer_provider.addAttributes([QgsField("Principal",QVariant.String)])
        layer_drenajes.commitChanges()
        idStream = layer_drenajes.fields().indexFromName('stream_typ')
        idControl = layer_drenajes.fields().indexFromName('Principal')
        layer_drenajes.startEditing()

        for d in selfea_d:
            for c in selfea_c:
                if(c.geometry().touches(d.geometry())):
                    id_ini=d.id()
                    attr_value={idStream:"P"}
                    print("Se encontró segmento inicial")
                    layer_provider.changeAttributeValues({id_ini:attr_value})
                    attr_value={idControl:"P"}
                    layer_provider.changeAttributeValues({id_ini:attr_value})


        layer_drenajes.commitChanges()
        layer_drenajes.removeSelection()
        layer_drenajes.select(id_ini)
        inicial =  layer_drenajes.selectedFeatures()[0]
        #print("Longitud inicial:"+str(inicial.geometry().length()))
        print("Orden inicial:"+str(inicial['orden']))

        listas_principal=tocanA(layer_drenajes,inicial) #genere listas
        l_id_principal=listas_principal[1]
        l_orden_principal=listas_principal[0]
        orden_principal=inicial['orden'] #extrea el orden de principal
        while orden_principal!=2:
            id_siguiente=selector(l_id_principal,l_orden_principal,orden_principal,inicial,idControl,layer_provider,layer_drenajes)
            layer_drenajes.removeSelection()
            layer_drenajes.select(id_siguiente)
            inicial=layer_drenajes.selectedFeatures()[0]
            listas_principal=tocanA(layer_drenajes,inicial) 
            l_id_principal=listas_principal[1]
            l_orden_principal=listas_principal[0]
            orden_principal=inicial['orden']





        while orden_principal!=1:
            id_siguiente=selectora(l_id_principal,l_orden_principal,orden_principal,inicial,idControl,layer_provider,layer_drenajes)
            layer_drenajes.removeSelection()
            layer_drenajes.select(id_siguiente)
            inicial=layer_drenajes.selectedFeatures()[0]
            listas_principal=tocanA(layer_drenajes,inicial) 
            l_id_principal=listas_principal[1]
            l_orden_principal=listas_principal[0]
            orden_principal=inicial['orden']

        layer_drenajes.removeSelection()
        layer_drenajes.selectByExpression( "\"Principal\" is Null" )
        selfea_d=layer_drenajes.selectedFeatures()
        layer_drenajes.removeSelection()
        layer_drenajes.selectByExpression( "\"Principal\"='P'" )
        selfea_p=layer_drenajes.selectedFeatures()
        layer_drenajes.removeSelection()
        layer_drenajes.selectByExpression( "\"orden\"='1'" )
        selfea_1=layer_drenajes.selectedFeatures()
        ids_final=[]
        long_final=[]
        for d in selfea_d:
                for p in selfea_p:
                    for uno in selfea_1:
                        if(uno.geometry().equals(d.geometry())):
                            if(d.geometry().touches(p.geometry())):
                                print(str(d.id())+' id')
                                ids_final.append(d.id())
                                long_final.append(d.geometry().length())
        index=long_final.index(max(long_final))
        layer_drenajes.startEditing()
        layer_drenajes.removeSelection()
        attr_value={idControl:"P"}
        layer_provider.changeAttributeValues({ids_final[index]:attr_value})
        layer_drenajes.commitChanges()

        layer_drenajes.startEditing()
        layer_drenajes.removeSelection()
        layer_drenajes.selectByExpression( "\"Principal\" is Null" )
        selfea_d=layer_drenajes.selectedFeatures()
        for d in selfea_d:
            attr_value={idControl:"N"}
            layer_provider.changeAttributeValues({d.id():attr_value})
        layer_drenajes.commitChanges()

        #Proceso para calcular perfil del cauce principal
        merge=directorio+'Temp/'+'merge.shp'
        layer_drenajes.selectByExpression( "\"Principal\"='P'" )
        selFea=layer_drenajes.selectedFeatures()
        layer_writer = QgsVectorFileWriter.writeAsVectorFormat(layer_drenajes, merge, "utf-8", layer_drenajes.crs(), "ESRI Shapefile", onlySelected=True)
        cauce = directorio+'Temp/' + 'cauce_merge.shp'
        processing.run("native:dissolve", {'INPUT':merge,'FIELD':[],'OUTPUT':cauce})
        buffer_cauce = directorio+'Temp/' + 'buffer_cauce.shp'
        ###BUFFER###
        #processing.algorithmHelp("qgis:buffer")
        parameters = {
        'DISSOLVE' : True,
        'DISTANCE' : 50,
        'END_CAP_STYLE' : 0,
        'INPUT' : cauce,
        'JOIN_STYLE' : 0,
        'MITER_LIMIT' : 2,
        'OUTPUT' : buffer_cauce,
        'SEGMENTS' : 5
        }
        ret = processing.run('qgis:buffer', parameters) 
        layer_buffer = QgsVectorLayer(buffer_cauce, "buffer cauce")
        ###CLIP RASTER BY EXTENT###
        #processing.algorithmHelp("gdal:cliprasterbyextent")
        #imagen dem
        clip_dem = directorio+'Temp/' + 'clip_dem.tif'
        parameters = {
        'DATA_TYPE' : 0,
        'EXTRA' : '',
        'INPUT' : entrada,
        'NODATA' : None,
        'OPTIONS' : '',
        'OUTPUT' : clip_dem,
        'PROJWIN' : layer_buffer.extent(),
        }
        ret = processing.run('gdal:cliprasterbyextent', parameters)
        ###POLYGONIZE (RASTER TO VECTOR)###
        poly_dem = directorio+'Temp/' + 'poly_dem.shp'
        
        parameters = {
        'BAND' : 1, ##Ojo: todos los dem son banda 1?
        'EIGHT_CONNECTEDNESS' : False,
        'EXTRA' : '', 
        'FIELD' : 'ALTURA',
        'INPUT' : clip_dem,
        'OUTPUT' : poly_dem
        }
        ret = processing.run('gdal:polygonize', parameters)

        ###SPLIT LINES BY MAXIMUM LENGTH###
        #processing.algorithmHelp("native:splitlinesbylength")
        cauce_split = directorio+'Temp/' + 'split_lines_100.shp'

        parameters = {
        'INPUT' : cauce, 
        'LENGTH' : distancia,  #PARAMETRIZAR
        'OUTPUT' : cauce_split
        }
        ret = processing.run('native:splitlinesbylength', parameters)

        ###LINE INTERSECTIONS###
        cauce_puntos = directorio+'Temp/' + 'cauce_puntos.shp'
        #processing.algorithmHelp("qgis:lineintersections")
        processing.run('qgis:lineintersections', {'INPUT':cauce_split,'INTERSECT':cauce_split,'OUTPUT':cauce_puntos})
        ###DISSOLVE###
        cauce_puntos_diss = directorio+'Temp/' + 'cauce_puntos_diss.shp'
        #processing.algorithmHelp("gdal:dissolve")
        parameters = {
        'COMPUTE_AREA' : False,
        'COMPUTE_STATISTICS' : False,
        'COUNT_FEATURES' : False,
        'EXPLODE_COLLECTIONS' : True,
        'FIELD' : '',
        'GEOMETRY' : 'geometry',
        'INPUT' : cauce_puntos,
        'OUTPUT' : cauce_puntos_diss,
        'OPTIONS' : '',
        'KEEP_ATTRIBUTES' : False,
        'STATISTICS_ATTRIBUTE' : ''
        }
        ret = processing.run('gdal:dissolve', parameters)
        #Calcular el id_bueno
        cauce_puntos = directorio+'Temp/' + 'cauce_puntos.shp'
        layer_cauce_puntos = QgsVectorLayer(cauce_puntos, "cauce puntos")
        layer_provider = layer_cauce_puntos.dataProvider()
        layer_cauce_puntos.startEditing()
        layer_provider.addAttributes([QgsField("id_bueno",QVariant.Int)])
        layer_cauce_puntos.updateFields()

        layer_cauce_puntos.selectAll()
        selfea_cp = layer_cauce_puntos.selectedFeatures()

        idBueno = layer_cauce_puntos.fields().indexFromName('id_bueno')
        for d in selfea_cp:
            id_cp=d.id()
            attr_value={idBueno:d.id()}
            layer_provider.changeAttributeValues({id_cp:attr_value})
        
        layer_cauce_puntos.commitChanges()
        ##JOIN ARREGLAR IDS
        puntos_join = directorio+'Temp/' + 'puntos_join.shp'
        parameters = {
        'INPUT':cauce_puntos_diss,
        'JOIN': cauce_puntos,
        'PREDICATE':[0],
        'JOIN_FIELDS':['id_bueno'],
        'METHOD':1,
        'DISCARD_NONMATCHING':False,
        'PREFIX':'',
        'OUTPUT':puntos_join
        }
        ret = processing.run("native:joinattributesbylocation", parameters)
        puntos_join = directorio+'Temp/' + 'puntos_join.shp'
        layer_p_join = QgsVectorLayer(puntos_join, "puntos join")

        features = sorted(layer_p_join.getFeatures(), key=get_name)

        layer_provider = layer_p_join.dataProvider()
        layer_provider.addAttributes([QgsField("id_final",QVariant.Int)])
        layer_p_join.updateFields()
        idFinal = layer_p_join.fields().indexFromName('id_final')
        i=0
        for feature in features:
            myVariable = feature['id_bueno']
            layer_p_join.selectByExpression(" \"id_bueno\" = '{}' ".format(myVariable))
            selFea=layer_p_join.selectedFeatures()
            #print(selFea[0].id())
            id_cambio = selFea[0].id()
            attr_value={idFinal:i}
            layer_provider.changeAttributeValues({id_cambio:attr_value})
            layer_p_join.removeSelection()
            i=i+1
        
        layer_p_join.commitChanges()
        ###FIX GEOMETRIES###
        #processing.algorithmHelp("native:fixgeometries")
        poly_demf = directorio+'Temp/' + 'poly_demf.shp'

        parameters = { 
        'INPUT' : poly_dem, 
        'OUTPUT' : poly_demf
        }
        ret = processing.run('native:fixgeometries', parameters)

        ###INTERSECTION###
        puntos_perfil = directorio+'Temp/' + 'puntos_perfil.shp'
        ####OJO CUANDO NO FUNCIONA Y SALE ERROR DE 
        ####Please fix the geometry or change the Processing setting to the “Ignore invalid input features” option
        ### CORRER LA HERRAMIENTA... fix geometries (Vector geometry qgis).
        #processing.algorithmHelp("qgis:intersection")
        parameters = {
        'INPUT' : puntos_join,
        'INPUT_FIELDS' : [],
        'OUTPUT' : puntos_perfil,
        'OVERLAY' : poly_demf,
        'OVERLAY_FIELDS' : ['ALTURA'],
        'OVERLAY_FIELDS_PREFIX' : ''
        }
        ret = processing.run('qgis:intersection', parameters)
        ###PLOTEAR###
        layer_pPerfil = QgsVectorLayer(puntos_perfil, "puntos perfil")
        layer_cauce = QgsVectorLayer(cauce, "cauce")
        layer_cauce.selectAll()
        selfea_cauce=layer_cauce.selectedFeatures()
        long_cauce=selfea_cauce[0].geometry().length()

        idx = layer_pPerfil.fields().indexFromName('ALTURA')
        maxH = layer_pPerfil.maximumValue(idx)
        minH = layer_pPerfil.minimumValue(idx)
        layer_pPerfil.selectAll()
        selfea_pPerfil=layer_pPerfil.selectedFeatures()

        features = sorted(layer_pPerfil.getFeatures(), key=get_nameF)
        j=0
        dist,elev=[],[]
        for j in range(len(features)):
            dist.append(features[j]['id_final']*distancia) #PARAMETRIZAR #Estaba *100+100
            elev.append(features[j]['ALTURA'])

        #Plot
        #https://gis.stackexchange.com/questions/372754/elevation-profile-with-labels-on-waypoints-qgis-python
        plt.plot(dist, elev, 'g')
        plt.xlabel("Distancia")
        plt.ylabel("Elevación")
        plt.title("Perfil del cauce principal")
        plt.hlines(range(minH,maxH,100), xmin=0, xmax=round(long_cauce), colors='silver', linestyles='solid') 
        x1,x2,y1,y2 = plt.axis()
        plt.axis((x1,x2,minH,maxH))
        plt.fill_between(dist, elev, color='#c1daba')

        #for labeltext, x, y, in labels:
        #    plt.annotate(labeltext, (x, y), color='g')
        plt.show()
        plt.savefig(directorio+'perfil_del_cauce.png')

        d = {'abcisa': dist,  'elevacion': elev}
        df_DB = pd.DataFrame(data=d)
        archivo=directorio+"perfil_del_cauce.csv"
        df_DB.to_csv(archivo)
        
        ##Generación de curva hipsométrica
        ###CSV###
        #processing.algorithmHelp("qgis:hypsometriccurves")
        parameters = {
        'BOUNDARY_LAYER' : cuenca_l,
        'INPUT_DEM' : entrada,
        'OUTPUT_DIRECTORY' : directorio,
        'STEP' : 100,
        'USE_PERCENTAGE' : True
        }
        ret = processing.run('qgis:hypsometriccurves', parameters)

        df=pd.read_csv(directorio+"histogram_cuenca_linea_0.csv", sep=",", header=0, names=["Area","Elevation"])

        AreasP=[]
        AreasP.append(df['Area'].values.tolist()[0])
        for i in range(1,len(df['Area'].values.tolist())):
            AreasP.append(df['Area'].values.tolist()[i]-df['Area'].values.tolist()[i-1])

        AreasAlt=[]
        for i in range(0,len(df['Area'].values.tolist())):
            AreasAlt.append(df['Area'].values.tolist()[len(df['Area'].values.tolist())-1]-df['Area'].values.tolist()[i])

        Elevation=df['Elevation'].values.tolist()
        Elev_str=[]
        for i in range(0,len(Elevation)):
            Elev_str.append(str(int(Elevation[i])))
        
        x_values1=AreasAlt
        y_values1=Elevation

        x_values2=AreasP
        y_values2=Elev_str


        fig=plt.figure()
        ax=fig.add_subplot(111, label="1")
        ax2=fig.add_subplot(111, label="2", frame_on=False)

        ax.barh(y_values2, x_values2, color="C1")
        ax.xaxis.tick_top()
        ax.yaxis.tick_right()
        ax.set_xlabel('Curva hipsométrica', color="black")      
        ax.xaxis.set_label_position('top') 
        ax.yaxis.set_label_position('right') 
        ax.tick_params(axis='x', colors="black")
        ax.tick_params(axis='y', colors="black")
        x1,x2,y1,y2 = plt.axis()
        plt.axis((int(min(AreasAlt)),int(max(AreasAlt)),int(min(Elevation)),int(max(Elevation))))

        ax2.plot(x_values1, y_values1, color="blue")
        ax2.set_xlabel("% Área", color="black")
        ax2.set_ylabel("Elevación (m)", color="black")
        ax2.tick_params(axis='x', colors="black")
        ax2.tick_params(axis='y', colors="black")

        plt.savefig(directorio+'curva_hipso_frecuencia.png')
        plt.show()
        
        ##Calculo de escalares
        layer_c = QgsVectorLayer(cuenca_poly, "cuenca") 
        layer_c.selectAll()
        selfea_c=layer_c.selectedFeatures()
        
        #Perimetro
        per_km=selfea_c[0].geometry().length()/1000
    
        #Area
        area_ha=selfea_c[0].geometry().area()*0.0001
        area_km=selfea_c[0].geometry().area()*0.000001

        #Coeficiente de compacidad (indice de gravelius)
        gravelius=per_km/(2*math.pi*(area_km/math.pi)**0.5)

        layer_cauce = QgsVectorLayer(cauce, "cauce") 
        layer_cauce.selectAll()
        selfea_cauce=layer_cauce.selectedFeatures()
        
        #Longitud de Cuenca
            ###EXTEND LINES###
        #processing.algorithmHelp("native:extendlines")
        cauce_ext = directorio+'Temp/' + 'cauce_ext.shp'
        parameters = {
        'END_DISTANCE' : 0, 
        'INPUT' : cauce, 
        'OUTPUT' : cauce_ext, 
        'START_DISTANCE' : selfea_cauce[0].geometry().length()*0.5
        }
        ret = processing.run('native:extendlines', parameters)

            ###CLIP###
        #processing.algorithmHelp("native:clip")
        cauce_acotado = directorio+'Temp/' + 'cauce_acotado.shp' 
        parameters = {
        'INPUT' : cauce_ext,
        'OUTPUT' : cauce_acotado, 
        'OVERLAY' : cuenca_poly
        }
        ret = processing.run('native:clip', parameters)
        layer_cauceAcotado = QgsVectorLayer(cauce_acotado, "cauce acotado") 
        layer_cauceAcotado.selectAll()
        selfea_cauceAcotado=layer_cauceAcotado.selectedFeatures()
        longitudCuenca_km = selfea_cauceAcotado[0].geometry().length() / 1000
        
        #Ancho de la Cuenca
        AnchoCuenca_km = area_km / longitudCuenca_km

        #Longitud total de la red hídrica
        layer_drenajes = QgsVectorLayer(drenajes, "red drenajes") 
        layer_drenajes.selectAll()
        selfea_d=layer_drenajes.selectedFeatures()

        longRed_km=0
        for i in selfea_d:
            long_d=i.geometry().length()/1000
            longRed_km=long_d+longRed_km
        
        #Densidad del drenaje
        densidadRed = longRed_km / area_km
        
        #Pendiente media de la cuenca
            ###MASK###
    
        raster_cuenca = directorio+'Temp/' + 'raster_cuenca.tif'
        parameters = {
        'INPUT':entrada,
        'MASK':cuenca_poly,
        'SOURCE_CRS':None,
        'TARGET_CRS':None,
        'NODATA':None,'ALPHA_BAND':False,
        'CROP_TO_CUTLINE':True,
        'KEEP_RESOLUTION':False,
        'SET_RESOLUTION':False,
        'X_RESOLUTION':None,
        'Y_RESOLUTION':None,
        'MULTITHREADING':False,
        'OPTIONS':'',
        'DATA_TYPE':0,
        'EXTRA':'',
        'OUTPUT':raster_cuenca
        }
        ret = processing.run('gdal:cliprasterbymasklayer', parameters)
        
        #processing.algorithmHelp("gdal:slope")
        pend_cuenca = directorio+'Temp/' + 'pend_cuenca.tif'
        parameters = {
        'AS_PERCENT' : True, 
        'BAND' : 1, 
        'COMPUTE_EDGES' : False,
        'EXTRA' : '', 
        'INPUT' : raster_cuenca, 
        'OPTIONS' : '', 
        'OUTPUT' : pend_cuenca, 
        'SCALE' : 1, 
        'ZEVENBERGEN' : False 
        }
        
        ret = processing.run('gdal:slope', parameters)
        pendienteCuenca_r = QgsRasterLayer(pend_cuenca, "Pendiente cuenca")
        provider = pendienteCuenca_r.dataProvider()
        stats = provider.bandStatistics(1, QgsRasterBandStats.All) 
        print("min value =", stats.minimumValue)
        print("max value =", stats.maximumValue)
        print("mean value =",stats.mean)
        pendMedCuenca_porc = stats.mean
        
        #Pendiente media del cauce principal
        puntos_perfil = directorio+'Temp/' + 'puntos_perfil.shp' #Borrar para plugin
        layer_pp = QgsVectorLayer(puntos_perfil, "puntos perfil") 
        layer_pp.selectAll()
        selfea_pp=layer_pp.selectedFeatures()

        pendMedCauce_porc=0
        for i in range(1,len(selfea_pp)):
            layer_pp.selectByExpression(" \"id_final\" = '{}' ".format(i))
            id_pendiente = layer_pp.selectedFeatures()[0].id()
            layer_pp.removeSelection()
            layer_pp.selectByExpression(" \"id_final\" = '{}' ".format(i-1))
            id_pendiente_a = layer_pp.selectedFeatures()[0].id()
            layer_pp.removeSelection()
            pendiente = (selfea_pp[id_pendiente]['ALTURA']-selfea_pp[id_pendiente_a]['ALTURA'])/distancia ##OJO se deberia ajustar en caso de generalizar el paso... #PARAMETRIZAR
            pendMedCauce_porc= (pendiente) + pendMedCauce_porc
            
            #OPCION 1
        pendMedCauce_porc = abs(pendMedCauce_porc / (len(selfea_pp)-1) * 100)
        
        for feature in selfea_cauce:
            for part in feature.geometry().asMultiPolyline():
                print("part")
                print(part[0].x(),part[0].y())
                print(part[len(part)-1].x(), part[len(part)-1].y())
        
            #OPCION 2
        layer_pp.selectByExpression(" \"id_final\" = '{}' ".format(0))
        id_inip = layer_pp.selectedFeatures()[0].id()
        layer_pp.removeSelection()
        layer_pp.selectByExpression(" \"id_final\" = '{}' ".format(len(selfea_pp)-1))
        id_finp = layer_pp.selectedFeatures()[0].id()
        layer_pp.removeSelection()
        pendMedCauce_porcAlt= abs((selfea_pp[id_inip]['ALTURA']-selfea_pp[id_finp]['ALTURA'])/ (selfea_cauce[0].geometry().length()))*100
        
        #Tiempo de concentración
        longCauceppal_km = selfea_cauce[0].geometry().length() / 1000
        longCauceppal_m = selfea_cauce[0].geometry().length()
        pendMedCauce_m = pendMedCauce_porc/100
        
            #METODO DE KIRPICH
        myDEM_cuenca = QgsRasterLayer(raster_cuenca, "Raster Cuenca")
        provider = myDEM_cuenca.dataProvider()
        stats = provider.bandStatistics(1, QgsRasterBandStats.All)
        altMax = stats.maximumValue
        altMin = stats.minimumValue
        S0 = altMax - altMin
        tc_kirpich = 0.066 * (longCauceppal_m/(S0**0.5))**0.77

            #METODO DE GIANDOTI
        tc_giandoti = (4*(area_km**0.5)+1.5*longCauceppal_km)/(25.3*(pendMedCauce_m*longCauceppal_km)**0.5) 

            #METODO DE TEMEZ
        tc_temez = 0.3*(longCauceppal_km/(pendMedCauce_porc**0.25))**0.76 

            #METODO DE PASSINI
        tc_passini = 0.108 * ((area_km * longCauceppal_km)**(1/3)/(pendMedCauce_m**0.5))
        
        escalaresMorfo = {
        'Perimetro km': per_km,  
        'Area Ha': area_ha,
        'Area km²': area_km,
        'Indice de gravelius': gravelius,
        'Longitud cuenca en km': longitudCuenca_km,
        'Ancho cuenca en km': AnchoCuenca_km, 
        'Longitud red en km': longRed_km,
        'Longitud cauce principal en km': longCauceppal_km,
        'Longitud cauce principal en m': longCauceppal_m,
        'Densidad de la red de drenaje': densidadRed,
        'Pendiente media de la Cuenca (%)': pendMedCuenca_porc,
        'Pendiente media del cauce (tramos) (%)': pendMedCauce_porc,
        'Pendiente media del cauce (cotas extremas) (%)': pendMedCauce_porcAlt,
        'Tiempo de concentración (Kirpich en horas)': tc_kirpich,
        'Tiempo de concentración (Giandotti en minutos)': tc_giandoti,
        'Tiempo de concentración (Temez en horas)': tc_temez,
        'Tiempo de concentración (Passini en horas)': tc_passini
        }
        df = pd.DataFrame([[key, escalaresMorfo[key]] for key in escalaresMorfo.keys()], columns=['Nombre', 'Valor'])
        archivo=directorio+"morfometriaCuenca.csv"
        df.to_csv(archivo, encoding='utf-8-sig')
        
        #Se agregan las capas al proyecto de qgis
        vlayer = QgsVectorLayer(cuenca_poly, "Divisoria de Aguas")
        QgsProject.instance().addMapLayer(vlayer, True)

        vlayer1 = QgsVectorLayer(drenajes, "Red de drenaje")
        QgsProject.instance().addMapLayer(vlayer1, True)

        
        table = QgsVectorLayer(archivo, "Morfometria de la Cuenca", "ogr")
        table.setProviderEncoding('utf-8')
        QgsProject.instance().addMapLayer(table, True)
        
        self.inicial = 0
        
        QMessageBox.information(self, "El proceso ha finalizado",
                                'Los archivos generados se encuentran en el directorio suministrado.')
        #Arreglando Directorio de Salida
        #import glob
        #os.mkdir(directorio + 'Temp')
        #os.mkdir(directorio + 'Img')
        #files = glob.glob(directorio +"/cauce_acotado.*")
        #for file in files:
        #    shutil.move(file, directorio + 'Temp/')
        #    #os.remove(file)
   
dialog = MorfoCuencasDialog()

dialog.show()




